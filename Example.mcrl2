%------------------------------------


sort Method = 	      struct method1 |  % for passing arguments in the call, so only for method_*_begin
			    method1' |  % for the possible return values, so only for method_*_end
			     method2 |
			  method2'(returnVal:Bool) |
			     method3 |
			    method3' |
			     method4 |
			    method4' |
			     method5 |
			   getSomeId |
		  getSomeId'(id:Int) |
			    method5' | 
			     method6 |
			    method6' |
			 innerMethod |
		   needSomeExtraHelp |
		  needSomeExtraHelp'(helpMeDecide:Bool) |
			appendToList ;
%---------ACTIONS---------------------------------

sort Class = struct A | B | C | D;

sort tupleClassA = struct tuple(id:Nat,id2:Nat);


act method_call_begin,method_var_begin:Method;
act method_call_end,method_var_end:Method;
act methodC_call_begin,methodC_var_begin:Method;
act methodC_call_end,methodC_var_end:Method;
act method_begin:Method;
act method_end:Method;
act methodC_begin:Method;
act methodC_end:Method;

act internal;
proc a(id:Class,data:tupleClassA) = 
method_begin(innerMethod). 
  method_call_begin(method1).
    method_call_end(method1').
method_end(innerMethod);


proc b(id:Class,cond1:Bool,cond2:Bool) = 
   method_var_begin(method1).
    method_call_begin(method2).sum cond1:Bool.method_call_end(method2'(cond1)). %sum needed here to get the value of result
    (cond1->
     method_begin(method3).method_end(method3')
     <>
    method_begin(method5).method_end(method5). 
    method_call_begin(getSomeId).sum id:Int.method_call_end(getSomeId'(id)).
    loop_b1(id)
    ).
% HERE BE ADDITIONAL HELP
   method_call_begin(needSomeExtraHelp).
   sum helpIsOnTheWay:Bool.method_call_end(needSomeExtraHelp'(helpIsOnTheWay)).
% END-HERE BE ADDITIONAL HELP
    (cond2-> method_var_end(method1')<> % how do I terminate HERE, not continue in case cond2 is true, but then NOT use ELSE for all the rest of the  behavior? Probably not possible. Ugly, but braces must be used
      (  
	method_call_begin(method6).method_call_end(method6')
				     
	   .method_var_end(method1')
      )
     );

proc loop_b1(id:Int) = 
(id>0)-> method_begin(method5).method_end(method5).
      method_call_begin(getSomeId).sum id:Nat.method_call_end(getSomeId'(id))
  .loop_b1(id) <> internal;

proc c(id:Class,list:List(Int)) = 
    (method_var_begin(method2).method_var_end(method2'(false))
    +
    method_var_begin(getSomeId).
    (method_var_end(getSomeId'(4)) +  method_var_end(getSomeId'(0))) %just a temp. hack to return "random" values and use them for looping decision
    + 
% HERE BE ADDITIONAL HELP
    method_var_begin(needSomeExtraHelp).method_var_end(needSomeExtraHelp'(false)) + % used to be a dot!!
% END-HERE BE ADDITIONAL HELP
    method_var_begin(method6).
    method_var_end(method6')

    )
 .c(list = list);

init hide ({internal},
 allow({internal,method_begin,method_end
},
comm({
method_call_begin|method_var_begin->
method_begin,
method_call_end|method_var_end->
method_end
}, 
				  a(A,tuple(1,2)) ||
				  b(B,false,false) ||
				   c(C,[]) 
)));
