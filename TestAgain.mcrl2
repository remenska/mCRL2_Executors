% ==================DATA 
sort eType = struct One | Two | Three;

sort TaskObject = struct taskObj(taskID:Nat,optimizationChain:List(eType),eType:eType) | None;


% =================
sort __execTypes = eType -> Int;
% cons empty: __execTypes;
map __execTypes_inc: __execTypes # eType -> __execTypes;
    __execTypes_get: __execTypes # eType -> Int;
    __execTypes_dec:__execTypes # eType -> __execTypes;
    __execTypes_set:__execTypes # eType -> __execTypes;
    __execTypes_eTypes:__execTypes -> List(eType);
var a: __execTypes;
    eType: eType;
eqn __execTypes_inc(a, eType) = a[eType -> succ(__execTypes_get(a,eType))];
    __execTypes_dec(a, eType) = if(__execTypes_get(a,eType)>0,
			a[eType -> pred(__execTypes_get(a,eType))],
			    a[eType -> __execTypes_get(a,eType)]);
    __execTypes_get(a, eType) = a(eType);
    __execTypes_set(a, eType) = a[eType->0];
    
map initialTypes:List(eType) -> __execTypes;
% 
% % =================
% 
% sort __execTypes = struct List(eType)
% 
% % =================
% sort __tasks = Nat -> TaskObject;
% map pop: __tasks # Nat -> __tasks;
%     get: __tasks # Nat -> TaskObject;
%     set: __tasks # Nat # TaskObject -> __tasks;
%     keys: __tasks -> List(Nat);
% var t:__tasks;
%     pos:Nat;
%     to:TaskObject;
% eqn pop(t,pos) = t[pos->None];
%     get(t,pos) = t(pos);
%     set(t,pos,to) = t[pos->to];
% 
% map init__tasks:__tasks;
% var taskObj1:TaskObject;
% % eqn taskObj1 = taskObj(1,[One,Two],Three);
% % eqn taskObj1 = 
%  eqn init__tasks(1) = taskObj(1,[One,Two],Three);
% 
% % =================
% 
act action2:TaskObject;
% 
% act action1:Int;
% proc P(ex:__execTypes,initTasks:__tasks) = 
% action1(ex(Two)).action1(__execTypes_get(__execTypes_inc(ex,One),One)).action2(initTasks(1)).
% action1(__execTypes_get(__execTypes_set(ex,Two),Two)).
% action2(get(pop(initTasks,1),1)).
% P(__execTypes_inc(ex,One),initTasks)
% ;
% 
% % proc Q = internal;
% 
% init P(initialTypes([One,Two,Three]),init__tasks);
